/* GRChombo
 * Copyright 2012 The GRChombo collaboration.
 * Please refer to LICENSE in GRChombo's root directory.
 */

// This class enforces A to be trace-free

#ifndef TRACEFIELDREMOVAL_HPP_
#define TRACEFIELDREMOVAL_HPP_

#include "CCZ4Geometry.hpp"
#include "Cell.hpp"
#include "Tensor.hpp"
#include "TensorAlgebra.hpp"
#include "UserVariables.hpp"
#include "VarsTools.hpp"
#include "FixedBGTensorField.hpp"
#include "ADMFixedBGVars.hpp"
#include "FourthOrderDerivatives.hpp"

template <class matter_t, class background_t> class TraceFieldRemoval
{

    template <class data_t> using Vars = typename matter_t::template Vars<data_t>;
    // Use the variable definition in the matter class
    //template <class data_t>
    //using MatterVars = typename matter_t::template Vars<data_t>;
    //template <class data_t> using Vars = FixedBGTensorField<TensorPotential>::template Vars<data_t>;
    // Now the non grid ADM vars
    template <class data_t> using MetricVars = ADMFixedBGVars::Vars<data_t>;

  protected:
    const background_t m_background; //the background
    const FourthOrderDerivatives m_deriv;
    //const matter_t m_matter;         //!< The matter object
    //const double m_dx;               //!< The matter object
    //const vars_t vars; // The field variables


  public:
  /*
 SetRest(const double tensor_mass, const std::array<double, CH_SPACEDIM> a_center,
                      const IsoSchwarzschildFixedBG::params_t a_bg_params,
                      const double a_dx, )//, const double a_fhat, const Tensor<1,data_t> a_fbar, const Tensor<2,data_t> a_fspatial)
        : m_bg_params(a_bg_params), m_deriv(a_dx)
        */
    TraceFieldRemoval(background_t a_background, const double a_dx)
        : m_background(a_background), m_deriv(a_dx)
    {
    }


    //void compute(const Cell<double> current_cell) const
    //template <class data_t> void compute(const Cell<data_t> current_cell) const
    template <class data_t> void compute(Cell<data_t> current_cell) const
    {
       
     // Struct for the non grid ADM vars

        //template <class data_t> using MetricVars = typename ADMFixedBGVars::template Vars<data_t>; 
        //template <class data_t> using MatterVars = typename matter_t::template Vars<data_t>;
        Vars<data_t> vars;
        //Tensor<2,data_t> fspatial; //Spatial component of the tensor field
        //Tensor<2,data_t> v; //Spatial rank 2 v field
        
        //Load metric vars

        MetricVars<double> metric_vars;

        m_background.compute_metric_background(metric_vars, current_cell);
        const auto gamma_UU = TensorAlgebra::compute_inverse_sym(metric_vars.gamma);
        const auto chris_phys = TensorAlgebra::compute_christoffel(metric_vars.d1_gamma, gamma_UU);

        //Make fspatial trace free
        //auto vars = current_cell.template load_vars<Vars>();
        const auto d1 = m_deriv.template diff1<Vars>(current_cell);
        auto local_vars = current_cell.template load_vars<Vars>();
        //TensorAlgebra::make_trace_free(local_vars.fspatial, metric_vars.gamma, gamma_UU);

        data_t fspatial_trace = TensorAlgebra::compute_trace(local_vars.fspatial, gamma_UU);
        
        data_t v_trace        = TensorAlgebra::compute_trace(local_vars.v, gamma_UU);

        data_t v_trace_correction;
        v_trace_correction = 0.0;
        FOR2(i,j)
        {
            v_trace_correction += gamma_UU[i][j] * d1.fbar[i][j];
            FOR1(k)
            {
                v_trace_correction += -gamma_UU[i][j] * chris_phys.ULL[k][i][j] * local_vars.fbar[k];
            }
        }
        
        
        FOR2(i,j)
        {
            local_vars.fspatial[i][j] += -(1.0/3.0) * metric_vars.gamma[i][j] * (fspatial_trace + local_vars.fhat/metric_vars.lapse);
            local_vars.v[i][j] += -(1.0/3.0) * metric_vars.gamma[i][j] * (v_trace - v_trace_correction);
        }
        
        //TensorAlgebra::make_trace_free(local_vars.v, metric_vars.gamma, gamma_UU);
        //vars.fspatial[0][0] -(1.0/3.0) * metric_vars.gamma[i][j] * (fspatial_trace + vars.fhat/metric_vars.lapse);
        //vars.v[i][j] -(1.0/3.0) * metric_vars.gamma[i][j] * (v_trace - v_trace_correction);
        
        vars.Xhat = local_vars.Xhat;

        vars.fhat = local_vars.fhat;
        //vars.fhat = 0.0;
        FOR1(i)
        {
            vars.Xspatial[i] = local_vars.Xspatial[i];
            vars.fbar[i] = local_vars.fbar[i];
            FOR1(j)
            {
                vars.fspatial[i][j] = local_vars.fspatial[i][j];
                vars.v[i][j] = local_vars.v[i][j];

                
            }
        }
        
        //change to store specific vars
        current_cell.store_vars(vars);
        /*
        current_cell.store_vars(vars.fspatial[0][0] -(1.0/3.0) * metric_vars.gamma[0][0] * (fspatial_trace + vars.fhat/metric_vars.lapse), c_fspatial11);
        current_cell.store_vars(vars.fspatial[0][1] -(1.0/3.0) * metric_vars.gamma[0][1] * (fspatial_trace + vars.fhat/metric_vars.lapse), c_fspatial12);
        current_cell.store_vars(vars.fspatial[0][2] -(1.0/3.0) * metric_vars.gamma[0][2] * (fspatial_trace + vars.fhat/metric_vars.lapse), c_fspatial13);
        current_cell.store_vars(vars.fspatial[1][1] -(1.0/3.0) * metric_vars.gamma[1][1] * (fspatial_trace + vars.fhat/metric_vars.lapse), c_fspatial22);
        current_cell.store_vars(vars.fspatial[1][2] -(1.0/3.0) * metric_vars.gamma[1][2] * (fspatial_trace + vars.fhat/metric_vars.lapse), c_fspatial23);
        current_cell.store_vars(vars.fspatial[2][2] -(1.0/3.0) * metric_vars.gamma[2][2] * (fspatial_trace + vars.fhat/metric_vars.lapse), c_fspatial33);

        current_cell.store_vars(vars.v[0][0] -(1.0/3.0) * metric_vars.gamma[0][0] * (v_trace - v_trace_correction), c_v11);
        current_cell.store_vars(vars.v[0][1] -(1.0/3.0) * metric_vars.gamma[0][1] * (v_trace - v_trace_correction), c_v12);
        current_cell.store_vars(vars.v[0][2] -(1.0/3.0) * metric_vars.gamma[0][2] * (v_trace - v_trace_correction), c_v13);
        current_cell.store_vars(vars.v[1][1] -(1.0/3.0) * metric_vars.gamma[1][1] * (v_trace - v_trace_correction), c_v22);
        current_cell.store_vars(vars.v[1][2] -(1.0/3.0) * metric_vars.gamma[1][2] * (v_trace - v_trace_correction), c_v23);
        current_cell.store_vars(vars.v[2][2] -(1.0/3.0) * metric_vars.gamma[2][2] * (v_trace - v_trace_correction), c_v33);        
        */
    }
};

/*
template <class data_t>
template <typename mapping_function_t>
void TraceFieldRemoval::Vars<data_t>::enum_mapping(
    mapping_function_t mapping_function)
{
    VarsTools::define_symmetric_enum_mapping(mapping_function, GRInterval<c_fspatial11, c_fspatial33>(), h);
    VarsTools::define_symmetric_enum_mapping(mapping_function, c_fhat , fhat);
}
*/
#endif /* TRACEFIELDREMOVAL_HPP_ */




/* GRChombo
 * Copyright 2012 The GRChombo collaboration.
 * Please refer to LICENSE in GRChombo's root directory.
 */

#ifndef FIXEDBGDIAGNOSTICS_HPP_
#define FIXEDBGDIAGNOSTICS_HPP_

#include "ADMFixedBGVars.hpp"
#include "CCZ4Geometry.hpp"
#include "Cell.hpp"
#include "Coordinates.hpp"
#include "FourthOrderDerivatives.hpp"
#include "GRInterval.hpp"
#include "Tensor.hpp"
#include "UserVariables.hpp" //This files needs NUM_VARS - total number of components
#include "VarsTools.hpp"
#include "simd.hpp"

//! Calculates the energy density rho and angular momentum density rhoJ
//! with matter type matter_t and writes it to the grid
template <class matter_t, class background_t> class FixedBGDiagnostics
{
    // Use the variable definition in the matter class
    template <class data_t>
    using MatterVars = typename matter_t::template Vars<data_t>;

    // Now the non grid ADM vars
    template <class data_t> using MetricVars = ADMFixedBGVars::Vars<data_t>;

  protected:
    const FourthOrderDerivatives
        m_deriv; //!< An object for calculating derivatives of the variables
    const matter_t m_matter;         //!< The matter object
    const double m_dx;               //!< The matter object
    const background_t m_background; //!< The matter object
    const std::array<double, CH_SPACEDIM> m_center;

  public:

  
    FixedBGDiagnostics(matter_t a_matter, background_t a_background, double a_dx,
                     std::array<double, CH_SPACEDIM> a_center)
        : m_matter(a_matter), m_deriv(a_dx), m_dx(a_dx),
          m_background(a_background), m_center(a_center)
    {
    }

    template <class data_t> void compute(Cell<data_t> current_cell) const
    {
        // copy data from chombo gridpoint into local variables, and calc 1st
        // derivs
        const auto vars = current_cell.template load_vars<MatterVars>();
        const auto d1 = m_deriv.template diff1<MatterVars>(current_cell);
        const auto d2 = m_deriv.template diff2<MatterVars>(current_cell);
        Coordinates<data_t> coords(current_cell, m_dx, m_center);

        // get the metric vars
        MetricVars<data_t> metric_vars;
        m_background.compute_metric_background(metric_vars, current_cell);

        using namespace TensorAlgebra;
        const auto gamma_UU = TensorAlgebra::compute_inverse_sym(metric_vars.gamma);
        const auto chris_phys =
            compute_christoffel(metric_vars.d1_gamma, gamma_UU);
   

   

        current_cell.store_vars(trace_field, c_trace_field);  
        current_cell.store_vars(trace_momentum, c_trace_momentum); 

        current_cell.store_vars(0.0, c_transverseScalar);

        current_cell.store_vars(transverseVector[0], c_transverseVector1);
        current_cell.store_vars(transverseVector[1], c_transverseVector2); 
        current_cell.store_vars(transverseVector[2], c_transverseVector3);  

        current_cell.store_vars(primaryScalar, c_primaryConstraintScalar);

        current_cell.store_vars(primaryVector[0], c_primaryConstraintVector1);
        current_cell.store_vars(primaryVector[1], c_primaryConstraintVector2);
        current_cell.store_vars(primaryVector[2], c_primaryConstraintVector3);

        current_cell.store_vars(rho_eff, c_rho_eff);
    
    }
};

#endif /* FIXEDBGDIAGNOSTICS_HPP_ */
